[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/new-new-test-post/index.html",
    "href": "posts/new-new-test-post/index.html",
    "title": "Timnit Gebru",
    "section": "",
    "text": "from source import Perceptron\np = Perceptron()\n\nI did it!!\nnot implemented\nThis is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/new-new-test-post/index.html#math",
    "href": "posts/new-new-test-post/index.html#math",
    "title": "Timnit Gebru",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "posts/example-blog-post/index.html",
    "href": "posts/example-blog-post/index.html",
    "title": "Hello Blog",
    "section": "",
    "text": "from source import Perceptron\nThis is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/example-blog-post/index.html#math",
    "href": "posts/example-blog-post/index.html#math",
    "title": "Hello Blog",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "posts/new-test-post/index.html",
    "href": "posts/new-test-post/index.html",
    "title": "Second Post",
    "section": "",
    "text": "This is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/new-test-post/index.html#math",
    "href": "posts/new-test-post/index.html#math",
    "title": "Second Post",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "Bias Replication Study\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/bias-replication-post/Bias-Replication.html",
    "href": "posts/bias-replication-post/Bias-Replication.html",
    "title": "Bias Replication Study",
    "section": "",
    "text": "This data frame represents disparities in medical data, including medical cost, risk score, and number of chronic illnesses, between Black and white patients. The plots shown are visual representations of such disparities, with clear distinctions between the costs incurred by Black and white patients and the likelihood of being referred to a high-risk medical program for a given number of illnesses. The linear regression I performed displays logarithmic coefficient w_b, which, when presented as \\(e^(w_b)\\), represents the percentage of a white patient’s cost that a Black patient must pay. My calculation revealed that a Black patient pays over 100% of what a white patient pays for the same illness(es).\n\nimport pandas as pd\nurl = \"https://gitlab.com/labsysmed/dissecting-bias/-/raw/master/data/data_new.csv?inline=false\"\ndf = pd.read_csv(url)\ndf\n\n\n\n\n\n\n\n\nrisk_score_t\nprogram_enrolled_t\ncost_t\ncost_avoidable_t\nbps_mean_t\nghba1c_mean_t\nhct_mean_t\ncre_mean_t\nldl_mean_t\nrace\n...\ntrig_min-high_tm1\ntrig_min-normal_tm1\ntrig_mean-low_tm1\ntrig_mean-high_tm1\ntrig_mean-normal_tm1\ntrig_max-low_tm1\ntrig_max-high_tm1\ntrig_max-normal_tm1\ngagne_sum_tm1\ngagne_sum_t\n\n\n\n\n0\n1.987430\n0\n1200.0\n0.0\nNaN\n5.4\nNaN\n1.110000\n194.0\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n1\n7.677934\n0\n2600.0\n0.0\n119.0\n5.5\n40.4\n0.860000\n93.0\nwhite\n...\n0\n1\n0\n0\n1\n0\n0\n1\n4\n3\n\n\n2\n0.407678\n0\n500.0\n0.0\nNaN\nNaN\nNaN\nNaN\nNaN\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n3\n0.798369\n0\n1300.0\n0.0\n117.0\nNaN\nNaN\nNaN\nNaN\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n4\n17.513165\n0\n1100.0\n0.0\n116.0\nNaN\n34.1\n1.303333\n53.0\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n48779\n0.611517\n0\n800.0\n0.0\nNaN\nNaN\nNaN\n1.090000\n148.0\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n48780\n2.615933\n0\n2200.0\n0.0\n112.0\nNaN\n41.4\n0.810000\n172.0\nwhite\n...\n0\n1\n0\n0\n1\n0\n0\n1\n1\n1\n\n\n48781\n1.358926\n0\n800.0\n0.0\n105.0\nNaN\nNaN\nNaN\nNaN\nwhite\n...\n0\n1\n0\n0\n1\n0\n0\n1\n1\n0\n\n\n48782\n10.990318\n0\n1300.0\n0.0\n132.0\nNaN\nNaN\nNaN\nNaN\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n3\n3\n\n\n48783\n1.681671\n0\n4400.0\n0.0\n115.0\n5.6\n36.6\n0.940000\nNaN\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n\n\n48784 rows × 160 columns\n\n\n\n\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Calculate risk score percentiles\ndf['risk_score_percentile'] = df['risk_score_t'].rank(pct=True).round(2)\n\n\n# Calculate mean number of gagne_sum_t within each risk score percentile\nmean_gagne_per_percentile = df.groupby(['risk_score_percentile', 'race'])['gagne_sum_t'].mean().reset_index()\n\n\n# Plot\nsns.scatterplot(data=mean_gagne_per_percentile, x='gagne_sum_t', y='risk_score_percentile', hue='race', style='race')\nplt.xlabel('Mean Chronic Illnesses')\nplt.ylabel('Risk Score Percentile')\nplt.xlim(0,8)\nplt.show()\n\n\n\n\n\n\n\n\nIn this figure we plot risk score percentile by the mean number of chronic illnesses within each percentile, with data points separated by race. Here we see a clear difference between races, with white patients more likely to be given a higher risk score than Black patients with the same number of chronic illnesses. If Patient A were white and Patient B were Black, and both patients had the same chronic illnesses, Patient A would be significantly more likely to have a higher risk score and be referred to a high-risk care management program.\n\n\ndf_cost = df.groupby(['risk_score_percentile', 'race'])['cost_t'].mean().reset_index()\n\ndf_cost2 = df.groupby(['gagne_sum_t', 'race'])['cost_t'].mean().reset_index()\n\n#make two subplots with the same y-axis\nfig, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(10, 5))\n# Plot\np1 = sns.scatterplot(data=df_cost, x='risk_score_percentile', y='cost_t', hue='race', style='race', ax = ax1)\nplt.xlabel('Percentile Risk Score')\nplt.ylabel('Total Medical Expenditures')\nplt.gca().semilogy()\n\np2 = sns.scatterplot(data=df_cost2, x='gagne_sum_t', y='cost_t', hue='race', style='race', ax = ax2)\nplt.xlabel('Number of chronic illnesses')\n\nText(0, 0.5, 'Total Medical Expenditures')\n\n\n\n\n\n\n\n\n\nThese figures suggest that, for Black patients, as risk score and number of chronic illnesses increase, medical expenditures increase at a higher rate than that of white patients. For lower risk scores and chronic illness counts, white patients seem to have slightly higher medical costs than for Black patients, but it appears as though Black patients are penalized more severely for having more illnesses and being of higher risk.\n\nimport numpy as np\n\n# Calculate the percentage of patients with 5 or fewer chronic conditions\npercentage = (len(df[df['gagne_sum_t'] &lt;= 5]) / len(df)) * 100\n\n# 95.53952115447689 - choice to use patients with 5 or fewer chronic conditions makes sense, \n# as 96% of patients have 5 or fewer chronic conditions.\n\n# Eliminate subjects with 0 cost, perform log function on cost column\ndf = df[df['cost_t'] &gt; 0]\ndf['log_cost'] = df['cost_t'].apply(lambda x: np.log(x))\n\n# Create a dummy column for the race variable\ndf['race_encoded'] = pd.get_dummies(df['race'], drop_first=True)\n\n# Separate the data into predictor variables (X) and target variable (y)\nX = df[['race_encoded', 'gagne_sum_t']]\ny = df['log_cost']\n\n\n\n\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.preprocessing import PolynomialFeatures\n\n# Function to add polynomial features\ndef add_polynomial_features(X, degree):\n    X_ = X.copy()\n    for j in range(1, degree):\n        X_[f\"poly_{j}\"] = X_[\"gagne_sum_t\"]**j\n    return X_\n\n# Create different degrees of polynomial features and compute cross-validation scores\ndegrees = range(1, 15)\nscores = []\n\nfor degree in degrees:\n    # Add polynomial features\n    X_poly = add_polynomial_features(X, degree)\n    \n    # Perform cross-validation with linear regression\n    lr = LinearRegression()\n    cv_score = cross_val_score(lr, X_poly, y, cv=5).mean()\n    scores.append(cv_score)\n\n# Determine the optimal degree based on cross-validation scores\noptimal_degree = degrees[np.argmax(scores)]\nprint(\"Optimal degree based on cross-validation:\", optimal_degree)\n\n# Construct data with the optimal number of polynomial features\nX_poly_optimal = add_polynomial_features(X, optimal_degree)\n\n# Fit the final linear regression model\nlr_final = LinearRegression()\nlr_final.fit(X_poly_optimal, y)\n\n# Get coefficients of the linear regression model\ncoefficients = lr_final.coef_\n\n\n# Identify the coefficient corresponding to the Black race\nwb = coefficients[-1]\nprint(\"w_b: \", wb)\n\n# Compute e^wb\ne_wb = np.exp(wb)\nprint(\"e^w_b: \", e_wb)\n\nOptimal degree based on cross-validation: 10\nw_b:  9.390071033164823e-08\ne^w_b:  1.0000000939007148\n\n\nThis linear regression model worked best with cross validation on 10 polynomial degrees. After fitting the final linear regression model, the value I received for e^(w_b) was 1.0000000939007148, indicating that a Black patient pays slightly over 100% of the cost that an equally sick white patient must pay."
  },
  {
    "objectID": "posts/bias-replication-post/Bias-Replication.html#abstract",
    "href": "posts/bias-replication-post/Bias-Replication.html#abstract",
    "title": "Bias Replication Study",
    "section": "",
    "text": "This data frame represents disparities in medical data, including medical cost, risk score, and number of chronic illnesses, between Black and white patients. The plots shown are visual representations of such disparities, with clear distinctions between the costs incurred by Black and white patients and the likelihood of being referred to a high-risk medical program for a given number of illnesses. The linear regression I performed displays logarithmic coefficient w_b, which, when presented as \\(e^(w_b)\\), represents the percentage of a white patient’s cost that a Black patient must pay. My calculation revealed that a Black patient pays over 100% of what a white patient pays for the same illness(es).\n\nimport pandas as pd\nurl = \"https://gitlab.com/labsysmed/dissecting-bias/-/raw/master/data/data_new.csv?inline=false\"\ndf = pd.read_csv(url)\ndf\n\n\n\n\n\n\n\n\nrisk_score_t\nprogram_enrolled_t\ncost_t\ncost_avoidable_t\nbps_mean_t\nghba1c_mean_t\nhct_mean_t\ncre_mean_t\nldl_mean_t\nrace\n...\ntrig_min-high_tm1\ntrig_min-normal_tm1\ntrig_mean-low_tm1\ntrig_mean-high_tm1\ntrig_mean-normal_tm1\ntrig_max-low_tm1\ntrig_max-high_tm1\ntrig_max-normal_tm1\ngagne_sum_tm1\ngagne_sum_t\n\n\n\n\n0\n1.987430\n0\n1200.0\n0.0\nNaN\n5.4\nNaN\n1.110000\n194.0\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n1\n7.677934\n0\n2600.0\n0.0\n119.0\n5.5\n40.4\n0.860000\n93.0\nwhite\n...\n0\n1\n0\n0\n1\n0\n0\n1\n4\n3\n\n\n2\n0.407678\n0\n500.0\n0.0\nNaN\nNaN\nNaN\nNaN\nNaN\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n3\n0.798369\n0\n1300.0\n0.0\n117.0\nNaN\nNaN\nNaN\nNaN\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n4\n17.513165\n0\n1100.0\n0.0\n116.0\nNaN\n34.1\n1.303333\n53.0\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n48779\n0.611517\n0\n800.0\n0.0\nNaN\nNaN\nNaN\n1.090000\n148.0\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n48780\n2.615933\n0\n2200.0\n0.0\n112.0\nNaN\n41.4\n0.810000\n172.0\nwhite\n...\n0\n1\n0\n0\n1\n0\n0\n1\n1\n1\n\n\n48781\n1.358926\n0\n800.0\n0.0\n105.0\nNaN\nNaN\nNaN\nNaN\nwhite\n...\n0\n1\n0\n0\n1\n0\n0\n1\n1\n0\n\n\n48782\n10.990318\n0\n1300.0\n0.0\n132.0\nNaN\nNaN\nNaN\nNaN\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n3\n3\n\n\n48783\n1.681671\n0\n4400.0\n0.0\n115.0\n5.6\n36.6\n0.940000\nNaN\nwhite\n...\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n\n\n48784 rows × 160 columns\n\n\n\n\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Calculate risk score percentiles\ndf['risk_score_percentile'] = df['risk_score_t'].rank(pct=True).round(2)\n\n\n# Calculate mean number of gagne_sum_t within each risk score percentile\nmean_gagne_per_percentile = df.groupby(['risk_score_percentile', 'race'])['gagne_sum_t'].mean().reset_index()\n\n\n# Plot\nsns.scatterplot(data=mean_gagne_per_percentile, x='gagne_sum_t', y='risk_score_percentile', hue='race', style='race')\nplt.xlabel('Mean Chronic Illnesses')\nplt.ylabel('Risk Score Percentile')\nplt.xlim(0,8)\nplt.show()\n\n\n\n\n\n\n\n\nIn this figure we plot risk score percentile by the mean number of chronic illnesses within each percentile, with data points separated by race. Here we see a clear difference between races, with white patients more likely to be given a higher risk score than Black patients with the same number of chronic illnesses. If Patient A were white and Patient B were Black, and both patients had the same chronic illnesses, Patient A would be significantly more likely to have a higher risk score and be referred to a high-risk care management program.\n\n\ndf_cost = df.groupby(['risk_score_percentile', 'race'])['cost_t'].mean().reset_index()\n\ndf_cost2 = df.groupby(['gagne_sum_t', 'race'])['cost_t'].mean().reset_index()\n\n#make two subplots with the same y-axis\nfig, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(10, 5))\n# Plot\np1 = sns.scatterplot(data=df_cost, x='risk_score_percentile', y='cost_t', hue='race', style='race', ax = ax1)\nplt.xlabel('Percentile Risk Score')\nplt.ylabel('Total Medical Expenditures')\nplt.gca().semilogy()\n\np2 = sns.scatterplot(data=df_cost2, x='gagne_sum_t', y='cost_t', hue='race', style='race', ax = ax2)\nplt.xlabel('Number of chronic illnesses')\n\nText(0, 0.5, 'Total Medical Expenditures')\n\n\n\n\n\n\n\n\n\nThese figures suggest that, for Black patients, as risk score and number of chronic illnesses increase, medical expenditures increase at a higher rate than that of white patients. For lower risk scores and chronic illness counts, white patients seem to have slightly higher medical costs than for Black patients, but it appears as though Black patients are penalized more severely for having more illnesses and being of higher risk.\n\nimport numpy as np\n\n# Calculate the percentage of patients with 5 or fewer chronic conditions\npercentage = (len(df[df['gagne_sum_t'] &lt;= 5]) / len(df)) * 100\n\n# 95.53952115447689 - choice to use patients with 5 or fewer chronic conditions makes sense, \n# as 96% of patients have 5 or fewer chronic conditions.\n\n# Eliminate subjects with 0 cost, perform log function on cost column\ndf = df[df['cost_t'] &gt; 0]\ndf['log_cost'] = df['cost_t'].apply(lambda x: np.log(x))\n\n# Create a dummy column for the race variable\ndf['race_encoded'] = pd.get_dummies(df['race'], drop_first=True)\n\n# Separate the data into predictor variables (X) and target variable (y)\nX = df[['race_encoded', 'gagne_sum_t']]\ny = df['log_cost']\n\n\n\n\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.preprocessing import PolynomialFeatures\n\n# Function to add polynomial features\ndef add_polynomial_features(X, degree):\n    X_ = X.copy()\n    for j in range(1, degree):\n        X_[f\"poly_{j}\"] = X_[\"gagne_sum_t\"]**j\n    return X_\n\n# Create different degrees of polynomial features and compute cross-validation scores\ndegrees = range(1, 15)\nscores = []\n\nfor degree in degrees:\n    # Add polynomial features\n    X_poly = add_polynomial_features(X, degree)\n    \n    # Perform cross-validation with linear regression\n    lr = LinearRegression()\n    cv_score = cross_val_score(lr, X_poly, y, cv=5).mean()\n    scores.append(cv_score)\n\n# Determine the optimal degree based on cross-validation scores\noptimal_degree = degrees[np.argmax(scores)]\nprint(\"Optimal degree based on cross-validation:\", optimal_degree)\n\n# Construct data with the optimal number of polynomial features\nX_poly_optimal = add_polynomial_features(X, optimal_degree)\n\n# Fit the final linear regression model\nlr_final = LinearRegression()\nlr_final.fit(X_poly_optimal, y)\n\n# Get coefficients of the linear regression model\ncoefficients = lr_final.coef_\n\n\n# Identify the coefficient corresponding to the Black race\nwb = coefficients[-1]\nprint(\"w_b: \", wb)\n\n# Compute e^wb\ne_wb = np.exp(wb)\nprint(\"e^w_b: \", e_wb)\n\nOptimal degree based on cross-validation: 10\nw_b:  9.390071033164823e-08\ne^w_b:  1.0000000939007148\n\n\nThis linear regression model worked best with cross validation on 10 polynomial degrees. After fitting the final linear regression model, the value I received for e^(w_b) was 1.0000000939007148, indicating that a Black patient pays slightly over 100% of the cost that an equally sick white patient must pay."
  }
]